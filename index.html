<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="田尚坤,java,javascript,jquery,互联网,架构,互联网技术" />








  <link rel="shortcut icon" type="image/x-icon" href="/wolf.ico?v=5.1.0" />






<meta name="description" content="天狼武士的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="天狼武士的Blog">
<meta property="og:url" content="http://www.tianshangkun.com/index.html">
<meta property="og:site_name" content="天狼武士的Blog">
<meta property="og:description" content="天狼武士的个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天狼武士的Blog">
<meta name="twitter:description" content="天狼武士的个人博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.tianshangkun.com/"/>





  <title> 天狼武士的Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  











  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1261718062&web_id=1261718062" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天狼武士的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">世界太大我想敲两行代码</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/11/10/SpringBoot集成Shiro并用MongoDB做Session存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/10/SpringBoot集成Shiro并用MongoDB做Session存储/" itemprop="url">
                  SpringBoot集成Shiro并用MongoDB做Session存储
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T14:04:12+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　之前项目鉴权一直使用的Shiro，那是在Spring MVC里面使用的比较多，而且都是用XML来配置，用Shiro来做权限控制相对比较简单而且成熟，而且我一直都把Shiro的session放在mongodb中，这个比较符合mongodb的设计初衷，而且在分布式项目中mongodb也作为一个中间层，用来很好很方便解决分布式环境下的session同步的问题</p>
<p>　自从SpringBoot问世之后我的项目基本上能用SpringBoot的就会用SpringBoot，用MAVEN做统一集中管理也很方便，虽然SpringBoot也提供了一套权限安全框架Spring Security，但是相对来说还是不是太好用，所以还是用Shiro来的方便一点，SpringBoot集成Shiro要比Spring MVC要简单的多，至少没有一堆XML配置，看起来更清爽，那么接下来我们就开始集成。</p>
<p>　第一步必然是在MAVEN中先添加Shiro和mongo的依赖，我用的Shiro版本是</p>
<pre><code>&lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt;
</code></pre><p>　添加依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;
    &lt;version&gt;${shiro.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;
    &lt;version&gt;${shiro.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
    &lt;version&gt;${shiro.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
      &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;
      &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
  &lt;dependency&gt;
  &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
  &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt;
  &lt;version&gt;1.7.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>　然后在application.xml或yml中配置mongodb</p>
<pre><code>spring.data.mongodb.host=127.0.0.1
spring.data.mongodb.port=27017
spring.data.mongodb.database=SHIRO_INFO
</code></pre><p>　配置完成之后我们开始正式写Shiro认证的代码，先自定义一个鉴权realm，继承自AuthorizingRealm</p>
<pre><code>public class ShiroDbRealm extends AuthorizingRealm {

  /**
   * 用户信息操作
   */
  private SystemUserService systemUserService;

  public ShiroDbRealm() {}

  public ShiroDbRealm(SystemUserService systemUserService) {
    this.systemUserService = systemUserService;
  }

  /**
   * 授权信息
   */
  @Override
  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
    // 首先从session中获取权限
    SimpleAuthorizationInfo info = (SimpleAuthorizationInfo) ShiroKit.getShiroSessionAttr(&quot;perms&quot;);
    if (null != info &amp;&amp; !CollectionUtils.isEmpty(info.getRoles())
        &amp;&amp; !CollectionUtils.isEmpty(info.getStringPermissions())) {
      return info;

    }
    return null;

  }

  /**
   * 认证信息
   */
  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken)
      throws AuthenticationException {
    UsernamePasswordToken token = (UsernamePasswordToken) authcToken;
    String userName = token.getUsername();
    if (userName != null &amp;&amp; !&quot;&quot;.equals(userName)) {
      SystemUser key = new SystemUser();
      key.setLoginName(token.getUsername());
      key.setPassword(String.valueOf(token.getPassword()));
      SystemUser user = systemUserService.login(key);

      if (user != null) {
        Subject userTemp = SecurityUtils.getSubject();
        userTemp.getSession().setAttribute(&quot;userId&quot;, user.getId());
        userTemp.getSession().setAttribute(&quot;userName&quot;, user.getUserName());
        return new SimpleAuthenticationInfo(user.getLoginName(), user.getPassword(), getName());
      }
    }
    return null;
  }

}
</code></pre><p>　存储session进mongodb的Repository和实现：</p>
<pre><code>public interface ShiroSessionRepository {

  /**
   * 
   * @param session
   */
  void saveSession(Session session);
  ......
}
</code></pre><p> MongoDBSessionRepository.java</p>
<pre><code>public class MongoDBSessionRepository implements ShiroSessionRepository {
    private MongoTemplate mongoTemplate;

    public MongoDBSessionRepository() {}

    public MongoDBSessionRepository(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }
    @Override
    public void saveSession(Session session) {
      if (session == null || session.getId() == null) {
        return;
      }
      SessionBean bean = new SessionBean();
      bean.setKey(getSessionKey(session.getId()));
      bean.setValue(SerializeUtil.serialize(session));
      bean.setPrincipal(null);
      bean.setHost(session.getHost());
      bean.setStartTimestamp(session.getStartTimestamp());
      bean.setLastAccessTime(session.getLastAccessTime());
      bean.setTimeoutTime(getTimeoutTime(session.getStartTimestamp(), session.getTimeout()));
      mongoTemplate.insert(bean);
    }
    ......
}
</code></pre><p>　ShiroSessionDAO.java</p>
<pre><code>public class ShiroSessionDAO extends AbstractSessionDAO {

 /**
  * 日志记录器
  */
 private static final Logger log = LoggerFactory.getLogger(ShiroSessionDAO.class);

 /**
  * 数据库存储
  */
 private ShiroSessionRepository shiroSessionRepository;

 /**
  * 
  * @return
  */
 public ShiroSessionRepository getShiroSessionRepository() {
   return shiroSessionRepository;
 }

 /**
  * 
  * @param shiroSessionRepository
  */
 public void setShiroSessionRepository(ShiroSessionRepository shiroSessionRepository) {
   this.shiroSessionRepository = shiroSessionRepository;
 }

 @Override
 public void update(Session session) throws UnknownSessionException {
   getShiroSessionRepository().updateSession(session);
 }

 @Override
 public void delete(Session session) {
   if (session == null) {
     log.error(&quot;session can not be null,delete failed&quot;);
     return;
   }
   Serializable id = session.getId();
   if (id != null) {
     getShiroSessionRepository().deleteSession(id);
   }
 }

 @Override
 public Collection&lt;Session&gt; getActiveSessions() {
   return getShiroSessionRepository().getAllSessions();
 }

 @Override
 protected Serializable doCreate(Session session) {
   Serializable sessionId = this.generateSessionId(session);
   this.assignSessionId(session, sessionId);
   getShiroSessionRepository().saveSession(session);
   return sessionId;
 }

 @Override
 protected Session doReadSession(Serializable sessionId) {
   return getShiroSessionRepository().getSession(sessionId);
 }

}
</code></pre><p>　OK！所有基础类已经完成，最后写一个config用来全部初始化和配置Shiro</p>
<pre><code>@Configuration
public class ShiroConfig {
  @Resource
  private MongoTemplate mongoTemplate;
  @Resource
  private SystemUserService systemUserService;// 这是用来判断用户名和密码的service

  @Bean
  public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) {
    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();

    // 必须设置 SecurityManager
    shiroFilterFactoryBean.setSecurityManager(securityManager);
    shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);
    // 登录成功后要跳转的链接
    shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;);
    // 未授权界面;
    shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/403&quot;);

    // 拦截器.
    Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;();
    filterChainDefinitionMap.put(&quot;/static/**&quot;, &quot;anon&quot;);
    filterChainDefinitionMap.put(&quot;/ajaxLogin&quot;, &quot;anon&quot;);
    filterChainDefinitionMap.put(&quot;/libs/**&quot;, &quot;anon&quot;);
    filterChainDefinitionMap.put(&quot;/images/**&quot;, &quot;anon&quot;);
    filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;);
    filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);

    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
    return shiroFilterFactoryBean;
  }

  public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(
      DefaultWebSecurityManager securityManager) {
    AuthorizationAttributeSourceAdvisor adv = new AuthorizationAttributeSourceAdvisor();
    adv.setSecurityManager(securityManager);
    return adv;
  }

  @Bean
  public DefaultWebSecurityManager securityManager(DefaultWebSessionManager sessionManager,
      ShiroDbRealm myShiroRealm) {
    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
    // 设置realm.
    securityManager.setRealm(myShiroRealm);
    securityManager.setSessionManager(sessionManager);
    return securityManager;
  }

  /**
   * 身份认证realm; (这里传递systemUserService给自定义的ShiroDbRealm初始化)
   * 
   * @return
   */
  @Bean
  public ShiroDbRealm myShiroRealm() {
    ShiroDbRealm myShiroRealm = new ShiroDbRealm(systemUserService);
    return myShiroRealm;
  }

  @Bean
  public DefaultWebSessionManager sessionManager(ShiroSessionDAO shiroSessionDao) {
    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();
    sessionManager.setGlobalSessionTimeout(1800000l);
    sessionManager.setDeleteInvalidSessions(true);
    sessionManager.setSessionValidationSchedulerEnabled(true);
    sessionManager.setSessionDAO(shiroSessionDao);
    sessionManager.setSessionIdCookieEnabled(true);
    SimpleCookie cookie = new SimpleCookie(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);
    cookie.setHttpOnly(true);
    cookie.setMaxAge(1800000);
    sessionManager.setSessionIdCookie(cookie);
    return sessionManager;
  }

  @Bean
  public ShiroSessionDAO shiroSessionDao(MongoDBSessionRepository shiroSessionRepository) {
    ShiroSessionDAO dao = new ShiroSessionDAO();
    dao.setShiroSessionRepository(shiroSessionRepository);
    return dao;
  }

  @Bean
  MongoDBSessionRepository shiroSessionRepository() {
    MongoDBSessionRepository resp = new MongoDBSessionRepository(mongoTemplate);
    return resp;
  }


}
</code></pre><p>　大功告成，这里只是一个简单的配置，代码也是我从项目里面节选和修改过的，至于在controller里面怎么使用，怎么做不同权限的鉴权工作那就在自己的代码里面实现就行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/07/12/Centos下搭建MariaDB集群/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/12/Centos下搭建MariaDB集群/" itemprop="url">
                  Centos下搭建MariaDB集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-12T22:27:31+08:00">
                2017-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　最近公司测试库改建，之前测试库上面装的是老的MySql，我顺手就把它换成了MariaDB，后来因为连的人太多就爆了Too Many Connections，本来很简单的事情，就让技术部一小伙子上去把连接数调大了一点，很简单，但是后来我发现他居然直接写在了My.cnf下面，显然他是不知道MariaDB早就从My.cnf下面扩展到了my.cnf.d文件夹下面，于是就跟他一番讲解，然后就引出了配置集群的话题，所以觉得有必要写一下MariaDB的一些配置和集群的配置方法。</p>
<p>　MariaDB本身就是MySql的一个分支，所以很多东西都是MySql延展下来的，既然要说的话就先从安装说起吧，在CentOS下安装还是很简单的，官网有很明确的说明以及各种安装方法，我个人比较喜欢yum源的安装方法，下面我们开始。</p>
<h2 id="第一步、安装MariaDB"><a href="#第一步、安装MariaDB" class="headerlink" title="第一步、安装MariaDB"></a>第一步、安装MariaDB</h2><p>　我们以最小集群来说，两台服务器先做主从配置，然后再做互为主从的配置,两台主机的IP分别为：192.168.70.135，192.168.70.137。</p>
<p>　先去官网上复制一下源的配置：</p>
<pre><code>https://downloads.mariadb.org/mariadb/repositories/#mirror=neusoft&amp;distro=CentOS&amp;distro_release=centos7-amd64--centos7&amp;version=10.2
</code></pre><p>　选择对应的操作系统版本及MariaDB的版本后会给出对应的配置，我这里选择的是Centos7,MariaDB的版本是10.2，所以给出的源是这样的：</p>
<pre><code># MariaDB 10.2 CentOS repository list - created 2017-07-12 14:25 UTC
# http://downloads.mariadb.org/mariadb/repositories/
[mariadb]
name = MariaDB
baseurl = http://yum.mariadb.org/10.2/centos7-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1
</code></pre><p>　OK！然后直接vim  /etc/yum.repos.d/MariaDB.repo复制进去保存即可，然后yum安装</p>
<pre><code>yum install MariaDB-server MariaDB-client
</code></pre><p>　不要以为安装完成就可以使用，mysql的用户和数据文件夹先指定一下，我的数据文件放在了/opt/data/mysql下面，执行下面的命令</p>
<pre><code>mysql_install_db --defaults-file=/etc/my.cnf --datadir=/opt/data/mysql/ --user=mysql
</code></pre><p>　OK!这时启动一下看看</p>
<pre><code>systemctl start mariadb
systemctl status mariadb
</code></pre><p>　不出意外，启动成功，设置一下root密码</p>
<pre><code>mysqladmin -u root password &quot;123456&quot;
</code></pre><p>　登录一下，不出意外应该成功了。</p>
<h2 id="第二步、配置MariaDB"><a href="#第二步、配置MariaDB" class="headerlink" title="第二步、配置MariaDB"></a>第二步、配置MariaDB</h2><p>　上面只是简单的安装，下面我们再简单的配置一下为集群做准备，先进入/etc/my.cnf.d/文件夹，MariaDB的所有配置文件都在这下面，主要配置文件还是在/etc/my.cnf.d/server.cnf下面</p>
<pre><code>vim /etc/my.cnf.d/server.cnf
</code></pre><p>　修改[mysqld]下面的内容</p>
<pre><code>[mysqld]
character-set-server=utf8
lower_case_table_names=1
init_connect=&apos;SET NAMES utf8&apos;
datadir=/opt/data/mysql
socket=/opt/data/mysql/mysql.sock
server-id   = 1
log-bin=mysql-bin
log-bin-index=master-bin.index
relay-log=relay-log
relay-log-index=relay-bin
log-slave=updates
</code></pre><p>　1.  character-set-server是设置数据库的编码格式<br>　2.  lower_case_table_names是设置数据库不区分大小写<br>　3.  datadir，socket是设置数据库实例的目录<br>　4.  server-id这个很重要，是指定集群中数据库服务的ID，在集群情况下每台数据库服务的ID都不能重复<br>　5.  log-bin和log-bin-index是开始MySQL的二进制日志并指定日志文件名<br>　6.  relay-log和relay-log-index是开始MySQL的中继日志并指定日志文件名<br>　7.  log-slave这个是设定slave节点的二进制输出，若没有设定此项则slave不会输出二进制，但是为了能够让slave也能够升级为master则该项最好配置一下</p>
<p>　为了能让两台MySQL服务能够互相连接，最好先创建让他们互相连接的数据库账户，现在master上简历用户，并授权，该账户为同步专用</p>
<pre><code>mysql&gt; GRANT REPLICATION SLAVE ON *.* TO repl@192.168.70.137 IDENTIFIED BY &apos;123456&apos;;
</code></pre><p>　PS：另外一台机器的/etc/my.cnf.d/server.cnf中其他配置都一样，就是server-id改成2，配置同步账户的时候IP地址改成可访问的机器的IP就行。</p>
<p>  配置完成后两台机器都重启。</p>
<h2 id="第三步、准备同步-配置主从"><a href="#第三步、准备同步-配置主从" class="headerlink" title="第三步、准备同步,配置主从"></a>第三步、准备同步,配置主从</h2><p>　全部配置并且两台机器都启动成功之后，就可以开始准备同步两台机器的数据了，在此之前先登录第一台机器的数据库，查看一下master的状态：</p>
<pre><code>mysql&gt; show master status;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 |      922 |              |                  |
+------------------+----------+--------------+------------------+
</code></pre><p>　File就是当前该数据库binlog日志的文件索引所在的文件名，position是当前日志索引的位置，将这两个值记录下来，然后登录第二台数据库服务器，启动slave：</p>
<pre><code>mysql&gt; CHANGE MASTER TO 
        MASTER_HOST=&apos;192.168.70.135&apos;,
        MASTER_USER=&apos;repl&apos;,
        MASTER_PASSWORD=&apos;123456&apos;,
        MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;,
        MASTER_LOG_POS=922;
</code></pre><p>　执行完成之后如果没有报错再执行show slave status\G命令查看slave节点的同步状态，如果ERROR没有显示错误并且Slave_IO_Running都为yes则表示同步成功。</p>
<pre><code>    MariaDB [(none)]&gt; show slave status\G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.70.135
                  Master_User: repl
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000001
          Read_Master_Log_Pos: 922
               Relay_Log_File: relay-bin.000003
                Relay_Log_Pos: 555
        Relay_Master_Log_File: mysql-bin.000001
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 922
              Relay_Log_Space: 858
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 1
               Master_SSL_Crl: 
           Master_SSL_Crlpath: 
                   Using_Gtid: No
                  Gtid_IO_Pos: 
      Replicate_Do_Domain_Ids: 
  Replicate_Ignore_Domain_Ids: 
                Parallel_Mode: conservative
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it
1 row in set (0.00 sec)
</code></pre><p>　这时在master节点的数据库服务器中创建数据库、创建表的话slave节点就直接可以看到了</p>
<p>　PS：同步之前最好先检查一下你服务器的防火墙有没有拦截3306端口！</p>
<h2 id="第四步、双主配置"><a href="#第四步、双主配置" class="headerlink" title="第四步、双主配置"></a>第四步、双主配置</h2><p>　前面的所有步骤完成后已经可以搭建单主多slave的架构了，如果想配置互为主从的其实很简单，在master节点中重复第三步，把master的IP指向对应的节点就好，不过需要注意的是Master可以有多个Slave，但是一个Slave只能挂靠一个Master！好的，我们先去192.168.70.137这台节点上查看一下master的status(就是第三步中的slave节点)</p>
<pre><code>mysql&gt; show master status;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000002 |      985 |              |                  |
+------------------+----------+--------------+------------------+
</code></pre><p>　然后再刚才master节点的数据库中执行：</p>
<pre><code>mysql&gt; CHANGE MASTER TO 
        MASTER_HOST=&apos;192.168.70.137&apos;,
        MASTER_USER=&apos;repl&apos;,
        MASTER_PASSWORD=&apos;123456&apos;,
        MASTER_LOG_FILE=&apos;mysql-bin.000002&apos;,
        MASTER_LOG_POS=985;
</code></pre><p>　如果没有报错，那么双主执行成功，在两台机器间创建数据库、创建表、创建数据测试一下，两台机器就会互相同步数据了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/06/13/Centos下docker搭建Hadoop集群/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/13/Centos下docker搭建Hadoop集群/" itemprop="url">
                  Centos下docker搭建Hadoop集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-13T15:56:26+08:00">
                2017-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　随着业务发展需要，数据量的逐步提升，需要用到Hadoop来处理一些数据，所以搭建一个Hadoop集群，搭建Hadoop集群需要多台主机，但是由于资源有限，所以刚好可以利用近些年比较火的docker来搭建，用docker搭建也有一个好处，就是一次构建多节点重复利用。在上服务器之前，现在自己的电脑里用虚拟机模拟一下，顺便可以做个记录，把可能遇到的坑先趟过去（谁叫我笔记本16G内存呢）。</p>
<h2 id="第一步、安装Centos，部署docker"><a href="#第一步、安装Centos，部署docker" class="headerlink" title="第一步、安装Centos，部署docker"></a>第一步、安装Centos，部署docker</h2><p>　先从Centos官网载一个最小版的Centos7镜像，用VMWare安装，由于是最小版镜像所以装完之后有很多组件需要手动yum安装，（什么？为什么不装完全版的？我要是有几台刀片我也装啊！）</p>
<p>　完成之后的第一步当然是换yum源：</p>
<pre><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup

wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
</code></pre><p>　安装完之后记得 yum makecache一下。由于是Minimal版，连最基本的网络工具都没有，所以全都开始手动安装：</p>
<pre><code>yum install -y wget
yum install -y gcc
</code></pre><p>　安装基本工具之后就是安装docker,docker安装很简单直接yum install -y docker，docker基本配置和使用就不再赘述了，docker的镜像本身下载很慢的，所以这里我用的是daocloud的加速器，那下载速度杠杠的！但是不知道daocloud最近怎么了，curl生成的加速器是有问题的，配置了之后docker启动不了，看了日志发现是他们修改的etc/docker/daemon.json有问题，里面多了一个逗号，把逗号去了就行。 接下来就是启动docker</p>
<pre><code>systemctl start docker
</code></pre><p>　没毛病，直接启动成功，接卸来下载镜像</p>
<pre><code>docker pull daocloud.io/centos:6
</code></pre><p>　为什么不用centos7而是用6，这个问题就比较搞笑了，刚开始用的就是7的镜像但是有个很严重的BUG就是systemd无法使用，也就是说容器内的服务是无法用systemctl管理的，网上也有解决方法，但是都不好使！所以退而求其次用centos6就行。镜像拉取完成之后启动镜像：</p>
<pre><code>docker run -it -h master --name master daocloud.io/library/centos:6 /bin/bash
</code></pre><p>　ok~!镜像启动成功，控制台会直接进入镜像内的控制台，如果想退回宿主机控制台直接ctrl+p ctrl+q可以从容器返回宿主机，再想回来直接docker attach 【容器名称或ID】。</p>
<h2 id="第二步、制作Hadoop镜像"><a href="#第二步、制作Hadoop镜像" class="headerlink" title="第二步、制作Hadoop镜像"></a>第二步、制作Hadoop镜像</h2><p>　进入容器控制台，开始搭建Hadoop，在搭建之前一样要先把基础工具给装了，Hadoop是JAVA写的所以JDK先给装上：</p>
<pre><code>wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz

mkdir /usr/java

tar -zxvf jdk-8u131-linux-x64.tar.gz -C /usr/java
</code></pre><p>　修改环境变量</p>
<pre><code>vim /etc/profile
#在最下方加入JAVA配置
export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL
export JAVA_HOME=/usr/java/jdk1.8.0_131
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
#source一下
source /etc/profile
</code></pre><p>　安装gcc,vim,lrzsz和ssh</p>
<pre><code>yum install -y gcc
yum install -y vim
yum install -y lrzsz
yum -y install openssh-server
yum -y install openssh-clients
</code></pre><p>　配置ssh免密登录</p>
<pre><code>ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre><p>　关闭烦人sellinux:</p>
<pre><code>setenforce 0
</code></pre><p>　启动ssh</p>
<pre><code>service sshd start
</code></pre><p>　测试一下</p>
<pre><code>ssh master
</code></pre><p>　如果没什么问题就代表一些准备就绪。</p>
<p>　完成之后开始下载Hadoop镜像：</p>
<pre><code>wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.8.0/hadoop-2.8.0.tar.gz
mkdir /usr/local/hadoop
tar -zxvf hadoop-2.8.0.tar.gz -C /usr/local/hadoop
</code></pre><p>　配置环境变量</p>
<pre><code>vim /etc/profile
#在最下方加入Hadoop配置
export HADOOP_HOME=/usr/local/hadoop/hadoop-2.8.0
export PATH=$PATH:$HADOOP_HOME/bin
</code></pre><p>　修改Hadoop的配置文件，进入Hadoop的目录</p>
<pre><code>cd /usr/local/hadoop/hadoop-2.8.0/etc/hadoop/
</code></pre><p>　在hadoop-env.sh 和 yarn-env.sh 在开头添加JAVA环境变量JAVA_HOME</p>
<p>　修改hadoop core-site.xml文件</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.defaultFS&lt;/name&gt;
        &lt;value&gt;hdfs://master:9000&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;io.file.buffer.size&lt;/name&gt;
        &lt;value&gt;131702&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;file:/home/tsk/hadoop-2.8.0/tmp&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>　修改hdfs-site.xml文件</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;
        &lt;value&gt;file:/home/tsk/hadoop-2.8.0/dfs/name&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;
        &lt;value&gt;file:/home/tsk/hadoop-2.8.0/dfs/data&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;2&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;
        &lt;value&gt;master:9001&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;
        &lt;value&gt;true&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>　修改mapred-site.xml文件</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;
        &lt;value&gt;master:10020&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;
        &lt;value&gt;master:19888&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>　修改yarn-site.xml</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;
        &lt;value&gt;master:8032&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;
        &lt;value&gt;master:8030&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;
        &lt;value&gt;master:8031&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;
        &lt;value&gt;master:8033&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;
        &lt;value&gt;master:8088&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;
        &lt;value&gt;1024&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>　由于我准备配置三个salve节点所以在slaves文件中添加</p>
<pre><code>slave1
slave2
slave3
</code></pre><p>　完成之后尝试一下</p>
<pre><code>ldd /usr/local/hadoop/hadoop-2.8.0/lib/native/libhadoop.so.1.0.0
</code></pre><p>　这时提示GLIBC_2.14 required，centos6的源最高到2.12，这里需要2.14，所以只能手动make安装</p>
<pre><code>wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz
tar zxvf glibc-2.14.tar.gz
cd glibc-2.14
mkdir build
cd build
../configure --prefix=/usr/local/glibc-2.14
make
make install
ln -sf /usr/local/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6
</code></pre><p>　完成之后再ldd就没有问题了！接下来就是构建上面做的所有操作，将其变成一个镜像以便复用，先Ctrl+p和Ctrl+q返回宿主机控制台然后输入命令：</p>
<pre><code>docker commit master tsk/hadoop
</code></pre><p>　等一会之后会发现镜像只做完成docker images一下就能看到自己只做的镜像了。</p>
<h2 id="第三步、启动镜像"><a href="#第三步、启动镜像" class="headerlink" title="第三步、启动镜像"></a>第三步、启动镜像</h2><p>　先配置docker的网络，给每台机器配置host</p>
<pre><code>docker inspect --format=&apos;{{.NetworkSettings.IPAddress}}&apos; master
</code></pre><p>　接下来逐个启动镜像：</p>
<pre><code>docker stop master
docker rm master
docker run -it -p 50070:50070 -p 19888:19888 -p 8088:8088 -h master --name master tsk/hadoop /bin/bash
docker run -it -h slave1 --name slave1 tsk/hadoop /bin/bash
docker run -it -h slave2 --name slave2 tsk/hadoop /bin/bash
docker run -it -h slave3 --name slave3 tsk/hadoop /bin/bash
</code></pre><p>　然后attach到每个节点上面source一下配置hosts，启动sshd，完成之后开始准备启动Hadoop</p>
<pre><code>hadoop namenode -format
/usr/local/hadoop/hadoop-2.8.0/sbin/start-all.sh
</code></pre><p>　最后要做的事情就是等待<del>~等待</del><del>~等待</del>~~~~！直到全部启动完成！完成之后用浏览器访问虚拟机IP地址:50070，如果没有任何问题的话你就可以看到如下画面，至此Hadoop集群搭建成功！</p>
<p><img src="/images/hadoop.png"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/05/04/获取我附近的商店方法-二-GeoHash算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/获取我附近的商店方法-二-GeoHash算法/" itemprop="url">
                  获取我附近的商店方法(二):GeoHash算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T17:03:29+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　上一篇提到根据坐标获取附近的商店根据半径计算的方法，这一篇说一下目前比较常用的GeoHash方法，先简单介绍一下GeoHash算法：</p>
<h3 id="认识GeoHash"><a href="#认识GeoHash" class="headerlink" title="认识GeoHash"></a>认识GeoHash</h3><p>　GeoHash算法将二维经纬度坐标直接转换成字符串，每一个字符串代表一个矩形区域，也就是说，这个矩形区域内所有的点（经纬度坐标）都共享相同的GeoHash字符串，字符串的长度越大，矩形的区域就越小，经度也就越高。字符串相似的表示距离相近，这样可以利用字符串的前缀匹配来查询附近的POI信息</p>
<h3 id="GeoHash算法的步骤"><a href="#GeoHash算法的步骤" class="headerlink" title="GeoHash算法的步骤"></a>GeoHash算法的步骤</h3><p>　地球纬度区间是[-90,90]，经度区间是[-180,180]，通过区间法对经度和纬度分别进行计算，假如我们获取到的当前坐标为经度-0.12866, 纬度38.534413，以纬度为例：</p>
<ol>
<li>将纬度平均分成两个区间：[-90,0),[0,90]，成为左区间和右区间，可以判断出38.534413属于右区间，则值为1,（如果属于左区间则值为0）；</li>
<li>接着将右区间继续划分，就变成了[0,45),[45,90],此时，38.534413属于左区间，则值为0</li>
<li>递归上述过程，则区间的值会越来越逼近38.534413</li>
<li>随着算法的进行，我们将会得到一个序列，序列的长度跟递归的次数有关，但是一定要保证的是经度和纬度的序列长度是一样的，我这里设置的递归长度是30，经度和纬度加起来就是60，</li>
<li>根据算法我们最终得到经度的序列为[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0]，纬度的序列为[1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0]，然后我们根据此序列再组合一个新的序列偶数位放经度，奇数位放纬度，把2串编码组合生成新串[0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0]，实际上这个序列是一串二进制</li>
<li>最后，我们将这个新串转换成十进制再使用0-9、b-z（去掉a, i, l, o）对这组十进制进行编码得到的字符串eyzgjnfr4p0p就是最终的GeoHash编码。下图是网上给出的不同编码长度给出的精度：</li>
</ol>
<p><img src="/images/geoHash.png"><br><img src="/images/geoHashLength.png"></p>
<p>　得到GeoHash的值之后可以同样的保存近数据库中，每次查询离我最近的数据的时候理论上来说可以根据精确度截取GeoHash的值进行模糊查询，但是这样查询是有问题的，因为你没法保证你每次查询时你的当前坐标刚好在这个矩形的正中间，如果你的坐标处在矩形的边界，那么你就无法获取其附近的数据，那么这个问题怎么解决呢？其实也很简单，以你当前所在位置的矩形为九宫格的中间格子，再获取其相邻的8个矩形。</p>
<p>　获取其他8个区域的GeoHash也很简单，上面的表已经给出了每一个区域内经度和纬度的宽度，那么直接加减后就可以得出周边相邻的8个格子，我这里自己写了一套GeoHash的算法，得出当前坐标的GeoHash的值以及相邻8个格子的值，代码比较多就不贴上来了，在GitHub上有一个别人写好的JAVA版本的可以直接拿来用，叫<a href="https://github.com/kungfoo/geohash-java" target="_blank" rel="external">geohash-java</a>,貌似maven的仓库中也有</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;ch.hsr&lt;/groupId&gt;
    &lt;artifactId&gt;geohash&lt;/artifactId&gt;
    &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p> 使用的方法也很简单</p>
<pre><code>GeoHash geoHash = GeoHash.withCharacterPrecision(38.534413, -0.12866, 12);
System.out.println(geoHash.toBase32());//获取当前的GeoHash的值
GeoHash[] adjacent = geoHash.getAdjacent();//获取整个九宫格的GeoHash的值
for (GeoHash hash : adjacent) {
  System.out.println(hash.toBase32());
}
</code></pre><p> 那么获取到整个九宫格之后至于查询和排序就简单多了，这里不再赘述。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/05/04/获取我附近的商店方法-一-根据坐标计算半径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/获取我附近的商店方法-一-根据坐标计算半径/" itemprop="url">
                  获取我附近的商店方法(一):根据坐标计算半径
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T16:30:34+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　现在所有的电商类APP都会有根据我的位置获取我附近的商户、离我最近的商户的筛选排序功能，那么这个功能是怎么实现的呢？显然单纯的数据库查询很难做到，一般数据库中只会存储商户的经度和纬度的坐标，那么根据这两个坐标获，再根据用户手机端定位到的经纬度坐标获经过计算得出离我最近的商户，这种实现方式可以有两种：第一种根据坐标及需要的距离计算出半径获取；第二种是通过geoHash算法进行转换。</p>
<p>　咱们并不讨论这两种方式的优缺点及具体的可行性问题，但从理论上说明一下两种方式的实现过程，这篇文章先说一下根据半径获取的方式：</p>
<p>　假定我们数据库中每个商户都有一个自己的地理位置坐标（经度：longitude；纬度：latitude），这两个参数可以精确到一个点，然后以这个点为圆心再根据需要的距离计算出最大的半径，代码如下：</p>
<pre><code>/**
* 地图坐标BEAN
* 
* @author sk.tian
* 
*/
public class LocationBean {
    private Double longitude; // 经度
    private Double latitude; // 纬度
    private int raidus; // 半径
    private Double minLat; // 最小纬度
    private Double maxLat; // 最大纬度
    private Double minLng; // 最小经度
    private Double maxLng; // 最大经度

    public Double getLongitude() {
        return longitude;
    }

    public void setLongitude(Double longitude) {
        this.longitude = longitude;
    }

    public Double getLatitude() {
        return latitude;
    }

    public void setLatitude(Double latitude) {
        this.latitude = latitude;
    }

    public int getRaidus() {
        return raidus;
    }

    public void setRaidus(int raidus) {
        this.raidus = raidus;
    }

    public Double getMinLat() {
        return minLat;
    }

    public void setMinLat(Double minLat) {
        this.minLat = minLat;
    }

    public Double getMaxLat() {
        return maxLat;
    }

    public void setMaxLat(Double maxLat) {
        this.maxLat = maxLat;
    }

    public Double getMinLng() {
        return minLng;
    }

    public void setMinLng(Double minLng) {
        this.minLng = minLng;
    }

    public Double getMaxLng() {
        return maxLng;
    }

    public void setMaxLng(Double maxLng) {
        this.maxLng = maxLng;
    }

}

/**
 * 根据坐标计算半径多少米范围之内的最大、最小经度和纬度
 * 
 * @param longitude
 *            经度
 * @param latitude
 *            纬度
 * @param raidus
 *            半径（米）
 * @return
 */
public static LocationBean loadCirle(Double longitude, Double latitude,
        int raidus) {
    LocationBean bean = new LocationBean();
    bean.setLongitude(longitude);
    bean.setLatitude(latitude);
    bean.setRaidus(raidus);
    Double degree = (24901 * 1609) / 360.0;
    double raidusMile = raidus;

    Double dpmLat = 1 / degree;
    Double radiusLat = dpmLat * raidusMile;
    Double minLat = latitude - radiusLat;
    Double maxLat = latitude + radiusLat;

    Double mpdLng = degree * Math.cos(latitude * (Math.PI / 180));
    Double dpmLng = 1 / mpdLng;
    Double radiusLng = dpmLng * raidusMile;
    Double minLng = longitude - radiusLng;
    Double maxLng = longitude + radiusLng;
    bean.setMaxLat(maxLat);
    bean.setMaxLng(maxLng);
    bean.setMinLat(minLat);
    bean.setMinLng(minLng);
    return bean;
}
</code></pre><p>  这个loadCirle方法就是计算出最大和最小经纬度的，将结果封装近LocationBean中，获取到locationBean之后，数据库查询的时候最大和最小的经纬度查询即可：</p>
<pre><code>select * from shops where latitude &gt;=#{minLat} and latitude&lt;=#{maxLat} and longitude&gt;=#{minLng} and longitude&lt;=#{maxLng}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/04/26/转-奥瑞旅行是什么鬼？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/26/转-奥瑞旅行是什么鬼？/" itemprop="url">
                  转:奥瑞旅行是什么鬼？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T10:38:10+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/aoorey1.jpg" class="full-image"></p>
<h2 id="以下文章截取自与奥瑞旅行CEO对其产品的一次不成熟的描述："><a href="#以下文章截取自与奥瑞旅行CEO对其产品的一次不成熟的描述：" class="headerlink" title="以下文章截取自与奥瑞旅行CEO对其产品的一次不成熟的描述："></a>以下文章截取自与奥瑞旅行CEO对其产品的一次不成熟的描述：</h2><blockquote>
<p><strong>奥瑞旅行：</strong>你出过国吗？从你起心动念到踏上异国他乡的土地再到回来，都需要花钱对吗？<br><strong>假装用户：</strong>是的，所有动作全部伴随着花钱。无论买旅游产品还是在境外消费（买东西或者吃顿饭）都得花钱。<br><strong>奥瑞旅行：</strong>但是你在境外花钱爽吗？花的值吗？<br><strong>假装用户：</strong>不爽是肯定的，国内啥都手机在线支付，习惯了；国外花钱太原始了，至于值不值的不好说。<br><strong>奥瑞旅行：</strong>没错，如果你在国外本来就要买这个东西，恰好现在有个软件，能让你买的时候打折，付款的时候手机快捷支付，你用不用？不仅如此，奥瑞旅行这个怪物除了给你提供最细致的旅游服务外，还要让你清楚、明白、实惠、便捷的在境外花好每一笔钱。<br><strong>假装用户：</strong>还有这么好的软件？请问哪里能下载？什么时候可以用？<br><strong>奥瑞旅行：</strong>别着急，今年6月以后去英国玩耍的小伙伴就可以率先用到啦！年底去欧洲玩耍的小伙伴也可以用啦。有没用很期待，心痒痒的？另外，奥瑞旅行的1.0版本海外中文接机、送机和包车定制服务也依然为你守候，专人专车从机场接你送到酒店，再从酒店送你去shopping，之后满载而归送回酒店。好土豪的样子有木有？！</p>
</blockquote>
<p>　　如文中描述，奥瑞旅行这款产品实际上是打破了中国人出境消费的很多弊端问题，比如目前中国人出境消费，要么使用现金，要么使用VISA、master card或银联卡等银行卡；使用现金的方式出境是收到金融管制的，就是你一次性可以带的货币数量是有限的，而使用银行卡要么换算成当地货币，要么转换成美金支付，很不方便，且毫无任何折扣可言，信用卡的话回来还钱也是个问题，经常会有人忘记还其他货币的钱而被银行纳入信用不良的人群之中。</p>
<p>　　之前我也说过中国的互联网发展速度是相当的快的，目前中国人直接跳过了信用卡时代步入了移动支付的时代，但仅限于中国，现在有这么一款产品直接将中国人的消费习惯带入国外，让中国人不管身处何处都可以享受到国内的移动支付便捷，这无疑是一个很不错的想法。</p>
<p>　　</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/04/20/angularJS创建一个上传照片的指令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/20/angularJS创建一个上传照片的指令/" itemprop="url">
                  angularJS创建一个上传照片的指令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T19:48:33+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　angularJS在近几年发展火热，也无疑是目前市面上来说比较牛逼且成熟的框架，在单页面前端应用当中应该可以说是王者，双向绑定省去了大量的前端代码，控制器在其作用于方面的控制也是相当腻害，今天我们要说的是另外一个比较牛逼的功能，就是angularJS的指令directive，之前没听说过angularJS指令的朋友请自行度娘，随便搜一条文章都比我说的详细，这次用一个我自己写的图片上传的指令来做为案例，详细说明一下实际操作过程中的指令。</p>
<p>　之前我们前端的附件上传用的是jqueryFileUpload，每次使用都要在页面把样式画好，然后再控制器中初始化upload组件，上传成功或失败时候还要做相应的处理，这样每次写一个附件上传都要写代码去处理，这样很重复劳动，所以就想利用angularJS的指令把重复劳动的环节给去掉，具体代码如下：</p>
<pre><code>.directive(&apos;imageUpload&apos;,[&apos;Constants&apos;,function(Constants){
return {
    restrict: &apos;E&apos;,
    scope: {
        scopeModel:&apos;=&apos;,
        title:&apos;@&apos;
    },
    template : &apos;&lt;fieldset&gt;&apos;
            +&apos;&lt;legend&gt;{{title}}&lt;span class=&quot;fileinput-button&quot;&gt;&lt;span&gt;重新上传&lt;/span&gt;&apos;
            +&apos;&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;/span&gt;&lt;/legend&gt;&apos;
            + &apos;&lt;span class=&quot;profile-picture&quot;&gt;&apos;
            + &apos;&lt;img class=&quot;img-responsive&quot; alt=&quot;{{title}}&quot; ng-src=&quot;{{loadImg(scopeModel)}}&quot; style=&quot;display: block;&quot;/&gt;&apos;
            + &apos;&lt;/fieldset&gt;&apos;,
    link : function(scope, element, attrs) {

        $(element).fileupload({
            url: &apos;file/upload&apos;,
            dataType: &apos;json&apos;,
            done: function(e, data) {
                var res = data.result;
                if(res.success){
                    scope.scopeModel=res.data.fileKey;
                    scope.$apply();
                }
            }
        });
        scope.loadImg=function(key){
            if(undefined==scope.scopeModel || null==scope.scopeModel || scope.scopeModel===&apos;&apos;){
                return $.ctx+&apos;/images/noImage.jpg&apos;;
            }
            if(scope.scopeModel.indexOf(&apos;http://&apos;)&gt;-1){
                return scope.scopeModel;
            }
            return $.ctx+&apos;/file/getFile?fileKey=&apos;+scope.scopeModel;
        }
    }
};
</code></pre><p>}]);</p>
<p>　指令完成之后在前端页面上只需要写一行代码就可以完成照片的加载（如果是修改页面需要加载出原照片）和上传功能，其中scopeModel是用来双向绑定的，在调用的时候把controller中的model传递进去之后可以实现指令和controller之间的双向绑定，代码中的template为element模板，可以根据具体的样式自己更换（我用的是bootstrap），使用如下：</p>
<pre><code>&lt;image-upload scope-model=&quot;imagePath&quot; title=&quot;照片上传&quot;&gt;&lt;/image-upload&gt;
</code></pre><p>　PS：代码为我实际业务代码中截取和删减过后的精简版。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/04/20/easyUI与angularJS整合（2）：表单提交篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/20/easyUI与angularJS整合（2）：表单提交篇/" itemprop="url">
                  easyUI与angularJS整合（2）：表单提交篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T14:53:33+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　我们知道easyUI的form表单提供了submit方法，可以直接提交表单的内容至服务器，默认的提交方式是form data,通过表单内元素的name和value作为键值对提交，但是如果你后端用的是springMVC的话，那默认他是无法接收到的，会返回HTTP415的错误，原因是POST提交数据的方法springMVC不接受，这个时候要么你在springMVC的上下文中加入支持form fata提交的配置，要么修改表单POST中content-type，都可以解决。</p>
<p>　在这里我选择的是直接改前端的代码，因为之前一直用的angularJS，数据提交都是用的angularJS的方法，springMVC已经配置过支持application/json的提交方式，所以直接修改content-type为”application/json;charset=UTF-8”的话会更好一点，但是看了easyUI的源码之后就知道，easyUI的form中是没有application/json;charset=UTF-8这种方式提交的，这个时候你就需要扩展easyUI了，顺便可以扩展一下easyUI的form中缺少的获取表单数据的方法（easyUI的form表单没有提供获取表单内数据的方法）。</p>
<p>　具体操作是这样的，我们可以通过$.extend方法对easyUI各种组件进行重写或者扩展，现在我们尝试一下扩展其form组件，增加一个获取表单内数据的方法getObjectData，让这个方法返回我们一个指定表单内的数据，以object类型返回：</p>
<pre><code>$.extend($.fn.form.methods, {  
getObjectData:function(jq, options){
    var target =jq[0];
    var data={};
    for (i = 0; i &lt; target.length; i++) {
        if(target[i].name &amp;&amp; target[i].getAttribute(&apos;disabled&apos;) === null){
            data[target[i].name]=target[i].value;
        }
        //form[i].name, form[i].value
    }
    return data;
}});
</code></pre><p>　这样就可以在需要的时候直接使用</p>
<pre><code>var data=$(&apos;#systemMenuEditForm&apos;).form(&apos;getObjectData&apos;);
</code></pre><p>　获取到表单数据之后就可以不用form的submit方法可以换成任何你想用的方法，鉴于我使用的了angularJS，所以直接用angularJS的$http.post方法提交就行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/04/15/easyUI与angularJS整合（1）：水火不容篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/15/easyUI与angularJS整合（1）：水火不容篇/" itemprop="url">
                  easyUI与angularJS整合（1）：水火不容篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-15T23:31:13+08:00">
                2017-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　上一篇文章已经说了，准备让easyUI与angularJS来一次亲密接触，当我搭建好了easyUI最经典的界面（layout的north、west、center）之后开始引入angularJS，结果他俩就给我来了一个当头一棒，本来好好的layout全屏页面居然直接就缩到了浏览器左上角的一小块，这个问题有点搞笑了，在思考了十分之一炷香之后发现了问题的所在，并且很快修复，其实我也没干别的事情，就是之前把jquery和easyUI的JS引用放在了angularJS的前面，十分之一炷香之后果断把angularJS的引用放在了jquery和easyUI的前面，在我一句呵呵哒之后继续下面的工作。</p>
<p>　下面的工作就是west加载功能列表，center放tab页签，加载功能列表点击后的具体页面，于是问题又出现了，tabs.add中href是远程的模板地址代码如下：</p>
<pre><code>$(&apos;#mainTab&apos;).tabs(&apos;add&apos;,{
    title:menu.name,
    href:menu.url,
    closable:true,
    cache:false,
    id:&apos;mainTab-&apos;+menu.id
});
</code></pre><p>　而我的每个功能模板使用一个angularJS的controller进行控制，我们都知道，tabs创建新的tab的时候如果传href参数远程异步加载的话angularJS是无法渲染的，也就是说当页面加载成功之后，没有被angualrJS渲染，所以angularJS也就无法控制该页面，索性easyUI的tabs组件有onLoad事件，可以在异步加载页面成功后回调该事件，参数是当前被加载的TAB，这就好办了，tabs的每一个tab都是一个panel组件，直接使用该tab.panel(‘body’).html()就可获取当前tab的HTML内容，然后使用angularJS提供的$compile方法对该页面进行渲染，代码如下：</p>
<pre><code>$(&apos;#mainTab&apos;).tabs({
    onLoad:function(ele,me){
        var obj=ele.panel(&apos;body&apos;).html();
        obj=$compile(obj)($scope);
        $scope.$apply();
    }
});
</code></pre><p>　这种方式可以保证tab被异步加载后执行部分angularJS渲染，但是奇怪的是页面的尖括号双向绑定无法使用，只能正常使用ng-开头的一些指令，同时表单如果使用了easyUI的表单的话是无法使用ng-model的，原因是easyUI对表单渲染的方式是保留原表单的内容并重新创建新的easyUI表单到页面上，所以在表现上来看并不是ng-model渲染不成功，只是你页面上看到的表单内容并不是你代码里写的，不过鉴于easyUI有自己的表单控制素有用不用angularJS的双向绑定也无所谓，可以用另一种方式去控制model。</p>
<p>　综上，easyUI和angularjS的混搭使用，angularJS只能当做控制层来使用，表现层级model绑定最好别交给easyUI来使用，既然是两种不同的框架那就只能取其交际使用方为上策。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.tianshangkun.com/2017/04/15/easyUI与angularJS整合（0）：水乳交融篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天狼武士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天狼武士的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/15/easyUI与angularJS整合（0）：水乳交融篇/" itemprop="url">
                  easyUI与angularJS整合（0）：水乳交融篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-15T22:56:55+08:00">
                2017-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> easyUI问世已经已经有很多年，其提供的框架非常适合做后台管理系统，尤其是ERP、OA等系统，提供了很多组件，虽然easyUI在后台管理系统的前端框架领域里面不是最牛逼的，最牛逼本人觉得应该是ExtJS，但是很无奈的是ExtJS在4.X版本之后就开始收费了，而且ExtJS由于在操作的过程总创建了大量的DOM，尤其是系统模块越多的情况下，DOM的数量会成倍增加，导致最终将用户的浏览器拖的很慢很慢，所以鉴于此，还是easyUI最适合。</p>
<p> 说到这里很多人不服，近些年出来很多前端框架，不管是页面的新颖程度，还是美观，还是自适应（WEB和手机端的切换）方面都秒杀easyUI，尤其是bootstrap的面世，确实，但是说句实话，ERP和OA之类的企业管理系统还是用easyUI比较方面，而且它的样式能够让大多数非挨踢从业人员接受，尤其是TAB标签和表单的呈现方式（个人或公司的喜好问题，这里不再赘述）。</p>
<p>　angularJS真的算是一款神奇的框架，自从问世以来博主我就一直在关注并且持续使用中，现在已经出到2代了，但是博主我还是在使用一代，其中唯一的原因就是那个操蛋的TypeScript和他的语法，真的很难让我接受，再说一代的版本提供的东西已经完全可以满足我日常开发的使用了，而且用起来很爽，何必咨询不快。</p>
<p>　说完easyUI和angularJS，再说说我之前那么多的废话是想干嘛，这就是这个系列的主体，之前一直用bootstrap和angularJS做整合使用，那是因为公司的电商系统及后台用这两个整合已经完全可以胜任了，但是最近公司因业务发展需要，需要做内部的ERP系统，于是我脑海里第一个冒出来的想法就是用easyUI和angularJS来做，这样省时省力，最关键的是我对这两款框架的熟悉程度都很高，所以不二之选就是让easyUI与angularjS水乳交融，在最短的时间内实现公司的ERP前端需求（后端以后再说）！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/1.jpg"
               alt="天狼武士" />
          <p class="site-author-name" itemprop="name">天狼武士</p>
           
              <p class="site-description motion-element" itemprop="description">天狼武士的个人博客</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1171031951" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">天狼武士</span>
</div>


<div class="powered-by">
  <a class="theme-link" href="http://www.tianshangkun.com">天狼武士</a> 专属博客
</div>

<div class="theme-info">
  苏ICP备 17021575
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "a9da684457284c92a0a08327257c0a71",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

</body>
</html>
